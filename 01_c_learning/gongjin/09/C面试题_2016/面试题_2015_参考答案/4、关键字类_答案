
================================= sizeof ====================================

1、请问下面的程序输出什么？
#include <stdio.h>
int main()  
{
    int i = 10;
    printf("i : %d\n",i);
    printf("sizeof(i++) is: %d\n",sizeof(i++));
    printf("i : %d\n",i);
    return 0;
}
参考答案：如果你觉得输出分别是，10，4，11，那么你就错了，错在了第三个，第一个是10没有什么问题，第二个是4，也没有什么问题，因为是32位机上一个int有4个字节。但是第三个为什么输出的不是11呢？居然还是10？原因是，sizeof不是一个函数，是一个操作符，其求i++的类型的size，这是一件可以在程序运行前（编译时）完成的事情，所以，sizeof(i++)直接就被4给取代了，在运行时也就不会有了i++这个表达式。


2、考查sizeof和自加操作
main()
{ 
	int i=3; 
	int j; 
	//double k;
	//j = sizeof(++i + ++k); 
	j = sizeof(++i + ++i); 
	printf("i=%d j=%d", i ,j);
}

这段程序的输出是:
(a) i=4 j=2
(b) i=3 j=2
(c) i=3 j=4
(d) i=3 j=6

答案(c)
sizeof 操作符给出其操作数需要占用的空间大小，它是在编译时就可确定的，所以其操作数即使是一个表达式，也不需要在运行时进行计算.     
( ++i + ++i )是不会执行的，所以 i 的值还是3


main ()
{
    int m = 10, n = 5;
    printf("result = %d\n", sizeof(m > n ? m : n+0.1));
}
8,sizeof计算表达式中最大的一个数据类型


3、某32位系统下, C程序，请计算sizeof 的值。
	char str[] = "hello.c/";   //字符串
	char c = 'a';
	char *p = str ;
	int n = 10;
   请计算
		sizeof (str ) = ？（1）
		sizeof ( p ) = ？（2）
		sizeof ( n ) = ？（3）
		void Foo (char str[100]){
			sizeof( str ) = ？（4）
		}
		void *p = malloc( 100 );
		sizeof ( p ) = ？（5）
（1）9 （2）4 （3） 4 （4）4 （5）4
   	 


4、有以下定义：
char *pmsg = “A”;
char msg[] = “A”;
char ch = ‘A’;
问：
sizeof(pmsg) = ?  //4
sizeof(msg) = ?   //2
sizeof(“A”) = ?   //2
sizeof(ch) = ?    //1
sizeof(‘A’) = ? （在C++中等于多少？）  //1(c++) 4(c)
void f(char param[100]) {
	sizeof(param) = ?  //4
}
因为： 
sizeof(pmsg) = 4 (指针变量的长度)
sizeof(msg) = 2 (字符数组的长度)
sizeof(”A”) = 2 (字符串的长度)
sizeof(ch) = 1 (字符变量的长度)
sizeof(‘A’) = 整型变量的长度 (在C语言中，字符常量的数据类型实际上是int；在C++中，它的数据类型是char，从而原式等于1)
sizeof(param) = 指针变量的长度 (数组名作参数时，传递的是数组的起始地址)



5、
static void test()
{
	char a[3][20] = {0};
	strcpy(a[0], "hello"); 
	strcpy(a[1], "world"); 

	printf("%d\n", sizeof(&a)); //&a的类型是char (*)[3][20]  4
	printf("%d\n", sizeof(a)); //60 (数组名在作为sizeof的操作数时，是按照数组类型来计算的，不会转化为指针)
	printf("%d\n", sizeof(*a)); //20
	printf("%c\n", *(*a + 1));  //e
	printf("%s\n", *(a + 1));   //world
	printf("%d\n", sizeof('s')); //4
}


6、
static void test()
{
	char d[20] = "hello";
	char a[3][20] = {"hello", "world", "linux"};
	char (*b)[20] = (char (*)[20])"hello";  
	char (*b1)[20] = a+1;
	char *c[20] = {"hello", "world", "linux"};
	printf("a[3][20]=%d, c[20]=%d\n", sizeof(a), sizeof(c));//60 80
	printf("a=%d\n", strlen(a[0]));	//5
}



7、下面程序运行的结果为什么可能不等于10？
int main(void)
{
	char aa[10];
	printf("%d",strlen(aa));
}
答案：sizeof()和初不初始化，没有关系；strlen()和初始化有关。



8、若有如下代码段，输出结果是什么？  
	char ch[] = {"abc\0def"}, *p = ch; 
	printf("sizeof(ch) = %d\n", sizeof(ch));//8
	printf("size = %d\n", sizeof("he\0llo")); //7
	printf("size = %d\n", strlen("he\\0llo")); //7
	printf("%c\n", *p+4); //e 




9、以下代码中的两个sizeof用法有问题吗？
void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
{
    for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i )
        if( 'a'<=str[i] && str[i]<='z' )
            str[i] -= ('a'-'A' );                     
}
int main()
{
	char str[] = "aBcDe";
	cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;
	UpperCase( str );
	printf("%s\n", str);
	return 0;
}

答：
函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。
注意:数组名作为函数参数时,退化为指针。数组名作为sizeof()参数时,数组名不退化,因为sizeof不是函数.
一个32位的机器,该机器的指针是多少位,只要看地址总线的位数就行了。80386的机子是32的地址总线。所以指针的位数就是4个字节了。



=================================== const ====================================

1、关键字const是什么含意？ 
	const关键字在C语言中用于声明”只读变量”，其值不可修改，但具有确定的数据类型。C编译器总是为其分配相应的存储单元。
	在C++中，const关键字用于声明常量，C++编译器视具体情况决定是为其分配存储单元还是仅将其作为编译期间的常量。
	在C++中，还可以修饰类的成员函数，不改变类中的数据成员.
	被const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

	我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）	
	如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？

const int a; 
int const a; 
const int *a; 
int * const a; 
int const * a const; //int const * const a ;

答：
	前两个的作用是一样，a是一个常整型数。
	第三个意味着a是一个指向常整型数的指针（也就是，指向的整型数是不可修改的，但指针可以，此最常见于函数的参数，当你只引用传进来指针所指向的值时应该加上const修饰符，程序中修改编译就不通过，可以减少程序的bug）。
	第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
	最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。

本质：const只是一个修饰符，不管怎么样a仍然是一个int型的变量。const在谁后面谁就不可修改，const在最前面则将其后移一位即可，二者等效。 （不是常数，可以是变量，只是你不能修改它）

	如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由： 
	1)关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。） 
	2)通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 
	3)合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

	const关键字至少有下列n个作用：
	(1) 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了
	(2) 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
	(3) 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
	(4) 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
	(5) 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：
	const classA operator*(const classA& a1,const classA& a2);
	operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：
	classA a, b, c;
	(a * b) = c; // 对a*b的结果赋值
	操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。
	


2、请说出const与#define 相比，有何优点？
答：
	const作用：修饰变量、修饰函数参数、修饰函数返回值三个作用。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
	1） const可以修饰数据类型，编译器可以对其变量进行类型安全检查。而宏常量没有数据类型，只进行简单的字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
   	2） define是编译时简单的进行文本替换，而const是运行时处理
   	3） 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试(不能用指针指向宏)。



3、有以下表达式：
	int a=248, b=4;
	int const c=21;
	const int *d=&a; // <==> int const *d = &a;
	int *const e=&b;
	//int const *f const = &a; //错误
	int const * const f = &a;
请问下列表达式哪些会被编译器禁止？为什么？
	*c = 32;
	d = &b;  //ok
	*d = 43;
	e = 34; 
	e = &a;
	f = 0x321f;
答案：
	*c = 32; 禁止
	*d = &b; 说了是const，禁止
	e = 34; 说了是const, 禁止
	e = &a; 说了是const, 禁止
	f = 0x321f; 禁止
	

====================================== 宏 ====================================

1、为什么要使用宏呢？
因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到调用函数的下一行代码继续执行。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。
而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。
但是宏也有很多的不尽人意的地方。
1)、宏不能访问对象的私有成员。
2)、宏的定义很容易产生二义性。
3)、宏定义的常量在代码区，很多调试器不能够对其调试
4)、宏会增大代码的尺寸
我们举个例子：
#define square(x) (x*x)
避免这些错误的方法是：给宏的参数都加上括号。
#define square(x) ((x)*(x))


2、宏有一些难以避免的问题，怎么解决呢？
	改用内联函数。内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。
	内联函数和宏很类似，而本质区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈出栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。
	声明内联函数看上去和普通函数非常相似：
	void f(int i, char c);
	当你定义一个内联函数时，在函数定义前加上 inline 关键字，并且将定义放入头文件：
inline void f(int i, char c)
{
// ...
}

//可以用__inline取代inline,这样编译时无需开启优化参数。
	#define __inline __attribute__((always_inline))

	内联函数既可以和函数体的定义放在在一起，也可以放在函数的声明的前面。
	inline int function(int i) {return i*i;} //放在函数定义前面
	inline int function(int); //放在函数声明前面
	调用方式和普通函数一样。但是执行速度确比一般函数的执行速度要快。

	当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。
	有上面的两者的特性，我们可以用内联函数完全取代预处理宏。



3、已知一个数组table，用一个宏定义，求出数据的元素个数。
答案：
#define NTBL (sizeof(table)/sizeof(table[0]))



4、用宏定义写出swap（x，y） 
#define swap(x, y) \
x = x + y;\
y = x - y;\
x = x - y;

或
#define swap(x, y)\ 
x = x ^ y;\ 
y = x ^ y;\ 
x = x ^ y;



5、写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
	#define MIN(A,B) ((A) <= (B) ? (A) : (B)) 

	这个面试题主要考查面试者对宏定义的使用。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能（当然主要是实时性哦，牺牲代码空间换取时间效率），嵌入代码经常是必须的方法。
	宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。程序员对宏定义的使用要非常小心，特别要注意两个问题：

(1) 谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答：
	#define MIN(A,B) (A) <= (B) ? (A) : (B)
	#define MIN(A,B) (A <= B ? A : B )  
	都应判0分；

(2) 防止宏的副作用。例如：当你写下面的代码时会发生什么事？least = MIN(*p++, b);
	此处考点：inline函数和宏的区别
　　	宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))
　　	对MIN(*p++, b)的作用结果是：((*p++) <= (b) ? (*p++) : (*p++)) 
　　	这个表达式会产生副作用，宏只是将参数完全替换。
　　	即MIN(*p++, b)进行宏展开后为（（*p++） <= (b) ? (*p++) : (b))，如果（*p++） <= (b)成立，则表达式的值为(*p++)，但由于在（*p++）<= (b)判断过程中改变了p的值，使得此时的 (*p++)并非（*p++）<= (b)中的值了，违背了？：号表达式的原意。所以指针p会作两次++自增操作。
　　	但是如果换做用内联函数实现，内联inline函数将进行参数检查，求出参数的值后再将此值带入函数中，因此（（A） <= (B) ? (A) : (B))中的A是一致的。
　　	除此之外，另一个应该判0分的解答是：#define MIN(A,B) ((A) <= (B) ? (A) : (B));
	这个解答在宏定义的后面加“;”，显示编写者对宏的概念模糊不清，只能被无情地判0分并被面试官淘汰。
	
	另外有一点：三元条件操作符（三目运算符）的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。



6、在16位系统下，用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
	我在这想看到几件事情：
	#define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
	懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
	可能有些人会写成 #define SECONDS_PER_YEAR 31536000UL
	意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
	如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
	


7、#define N 2
	#define M N+1
	#define NUM (M+1)*M/2     	
	int i, n;
	for(i=1,n=0; i<=NUM; i++)  //（2 + 1 + 1）* 2 + 1/2
		n++;	
问这个循环执行了几次？	

解答：
	i <= NUM
	  =(M+1)*M/2
	  =(N+1+1)*N+1/2
	   =(2+1+1)*2+1/2
	   =8



8、ASSERT()宏是干什么用的？
解答：
ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了就终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，你可以这样写程序： 
...... 
ASSERT( n != 0); 
k = 10 / n; 
...... 
ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。 
库函数assert.h中的assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。


9、
#ifdef NDEBUG
#define TRACE(S)
#else
#define TRACE(S) printf("%s\n", #S)
#endif
问：以上TRACE()宏的作用是什么？


10、以下是求一个数的平方的程序,请找出错误:
#define SQUARE(a) ((a)*(a))
int a=5;
int b;
b=SQUARE(a++);
答:结果与编译器相关,得到的可能不是平方值.
//(a++) * (a++)  ==> 5 * 6
//				 ==> 5 * 5
//				 ==> 6 * 6
//				 ==> 7 * 7


================================== static ====================================	
	
1、关键字static的作用是什么？
	这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
	1、在函数体中，一个被声明为静态的变量，该变量作用域从函数中声明的那一行开始到结束，在这一函数被调用过程中维持其值不变。
	2、在文件内（在模块内，但在函数体外），一个被声明为静态的变量可以被文件内所用函数访问，但不能被文件外其它函数访问。它是一个本地的全局变量。
	3、在模块(文件)内，一个被声明为静态的函数只可被这一模块(文件)内的其它函数调用。那就是，这个函数被限制在声明它的模块（文件）的本地范围内使用。
	大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。	
	
	static关键字至少有下列n个作用：
	(1) 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
	(2) 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
	(3) 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
	(4) 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
	(5) 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。


2、
请说出static关键字的3种用处：
/* file.c */
static int a;
int b;
static int fn()
{
	static int x;
	int y;
}
(1)用于全局变量：外部静态变量，只能在本源文件中被引用，不能被其它源文件所引用。
(2)用于局部变量：局部静态变量，在函数返回后存储单元不释放；下一次调用该函数时，该变量为上次函数返回时的值。
(3)用于函数：内部函数，只能被本源文件中的函数所调用，不能被其它源文件调用。	
	


3、
	static全局变量与普通的全局变量有什么区别？
	static局部变量和普通局部变量有什么区别？
	static函数与普通函数有什么区别？
答：
	1)全局变量(外部变量)的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
	2)从以上分析可以看出，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。　　                  
	3)static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。
综上所述:
static全局变量与普通的全局变量有什么区别：
	static全局变量只初使化一次，防止在其他文件单元中被引用; 　　
static局部变量和普通局部变量有什么区别：
	static局部变量只被初始化一次，下一次依据上一次结果值； 　　
static函数与普通函数有什么区别：
	static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝;
程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

	

4、intel：A.c 和B.c两个c文件中使用了两个相同名字的static全局变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?
static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。
他们都放在静态数据区，但是编译器对他们的命名是不同的。
如果要使变量在其他模块也有意义的话，需要使用extern关键字。



5、考查静态变量的知识
static int foo_counter(int i)
{
	static int count = 0;
	count += i;
	return count;
}
static void test15()
{
	int i = 0;
	int j = 0;

	for (i = 0; i < 3; i++)
		j = foo_counter(i);

	printf("%d\n", j);
}
本程序输出j的值是？ //3

相传高斯小学一年级的时候就会做这类等比数列的题目了.这道题考查的是静态变量的知识,当每次调用完函数之后,静态变量的值不会丢失,这是与栈中的临时局部变量明显不同的地方.
所以,第一次调用counter(0)之后,count =0
第二次调用 counter(1)后 count = 0+1;
第三次调用 counter(2) count = 1+2;    /* count = count + i */
	
	
	
6、写出程序运行结果
int sum(int a)
{
	auto int c=0; //<==> int c = 0;
	static int b=3;
	c+=1;
	b+=2;
	return (a+b+c);
}
void main()
{
	int i;
    int a = 2;
    for(int i = 0; i < 5; i++) {
		printf("%d,", sum(a)); //8、10、12、14、16
	}
}

答：
输出：8,10,12,14,16,
该题比较简单。只要注意b声明为static静态变量，其值在下次调用时是可以保持住上次结果的。	

=============================== volatile ====================================

1. 请解释volatile的含义？
	volatile字面意思是“易变的”。这个关键字来描述一个变量时，意味着给该变量赋值(写入)之后，马上再读取，写入的值与读取的值可能不一样,所以说它“易变的”。这是因为这个变量可能是一个寄存器，直接与外部设备相连，你写入之后，该寄存器也有可能被外部设备的写操作所改变; 或者，该变量被一个中断程序，或另一个进程改变了。volatile 不会被编译器优化影响。
	简而言之，volatile关键字用于声明内存映射的易失型变量，这类变量的值随时可能由于某种编译器所不知道的原因(例如，外部设备对其写入)所改变，所以编译器在进行代码优化时不能对其做任何的假设和依赖。


2、关键字volatile有什么含意，并给出三个不同的例子。使用时会对编译器有什么暗示。
答：
	一个定义为volatile的变量是说这变量可能会在编译器未监测到的情况下被意想不到地改变，这样，编译器就不会去假设这个变量的值了。由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
	精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份（由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部 RAM的优化）。下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器，通常在头文件中将硬件寄存器地址define为某个意义明确的表达式；硬件时钟） 
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables，即static变量)，在中断服务程序中修改的供其他程序检测用的变量需要加volatile声明；否则编译器可能对变量更新一次后每次都使用缓存值不再立即更新
3). 多线程应用中被几个任务共享的变量（可能被多个线程随时修改）

我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所有这些都要求volatile变量。不懂得volatile内容将会带来灾难。假设被面试者正确地回答了这些问题，我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。 

Volatile的完全扩展：
1). 一个参数既可以是const还可以是volatile吗？解释为什么。 
2). 一个指针可以是volatile 吗？解释为什么。 
3). 下面的函数有什么错误： 
int square(volatile int *ptr) 
{ 
	return *ptr * *ptr; 
} 

下面是答案： 
1). 是的。volatile可以和const一起使用，不过很少见。const关键字的意思是限制编程者自己不能修改变量的值；两者并不矛盾。例如一个内存映射的、只读的硬件寄存器，假设它的地址是p，则可以这样声明：volatile const unsigned int *p;
它是volatile因为它可能被意想不到地改变，它是const因为程序不应该试图去修改它。
2). 是的。尽管这并不很常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。
3). 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
 
int square(volatile int *ptr) 
{ 
	int a,b; 
	a = *ptr; 
	b = *ptr; 
	return a * b; 
} 
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返回值不是你所期望的平方值！正确的代码如下： 
long square(volatile int *ptr) 
{ 
	int a; 
	a = *ptr; 
	return a * a; 
}

另外，补充一些内容：关于volatile关键字在中断函数中的影响实例

串口发送数据，中断中对其检测，当中断产生后，置接收标志，主循环中检测此主标志，未用valotile修饰时，编译结果如下：

   [0xe59f41bc]   ldr      r4，0x30203378 ; = #0x302096f0

0x302031b8 [0xe5d40000]   ldrb     r0，[r4，#0]

while(!uart1_rxFlag);  //uart1_rxFlag为全局变量，在串口接收中断中置1

0x302031bc [0xe3500000]   cmp      r0，#0
0x302031c0 [0x0afffffd]   beq      0x302031bc; (Can_Int_Test + 0x17c)

即编译器对其进行了优化，读取一次uart1_rxFlag的值之后，将其存放在寄存器r0中，比较后，条件不满足，继续等待，但未重新取存储器中uart1_rxFlag的值，此时即使中断服务函数中修改了uart1_rxFlag的值，比较处仍然不能发现，就出现了无论如何程序就停在此处的问题。


// 加了volatile关键字后，编译的结果
302031b4  ldr      r4，0x30203378 ; = #0x302096f0

    while(uart1_rxFlag == 0);
302031b8 [0xe5d40000]   ldrb     r0，[r4，#0]
302031bc [0xe3500000]   cmp      r0，#0
302031c0 [0x0afffffc]   beq      0x302031b8  ; (Can_Int_Test + 0x288)

添加了关键字后，比较不等，跳转到重新取存储器中的uart1_rxFlag，因此任何时候uart1_rxFlag的值都是最新的。

一定程度的优化，去掉了读取uart1_rxFlag地址的语句。

定义一个易失性变量，编译器有一种技术叫数据流分析，分析程序中的变量在哪里被赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化。当编译器检查到代码没有修改字段的值，就有可能在你访问字段时提供上次访问的缓存值，这能够提高程序的效率，但有时这些优化会带来问题，不是我们程序所需要的，特点是对硬件寄存器操作的程序，这时可以用volatile关键字禁止做这些优化。

多任务环境下各任务间共享的标志应该加voatile关键字：在多线程访问某字段时，代码希望这些访问能够操作（读取）到字段的最新值，同时写到变量的操作能立即更新；对字段加上volatile关键字，那么对该字段的任何请求（读/写）都会立刻得到执行。 




3、嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa55。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下： 
int *ptr; 
ptr = (int *)0x67a9; 
*ptr = 0xaa55;
一个较晦涩的方法是： 
*(int * const)(0x67a9) = 0xaa55;
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
（上面是原题目解答）

另一种解答代码如下：
volatile int *ptr;
ptr = (volatile int *)0x67a9; //该地址并不能保证一定使用
*ptr = 0xaa66;

//如果想要该地址内能被存入我们希望的值，正确的方法：
volatile static int *ptr;  //nm看一下该变量的地址
ptr = (volatile int *)地址;
*ptr = 0xaa66;


=================================== typedef ====================================	


1、考查typedef类型定义,函数指针
typedef int (*tmp)(float * , float *); //定义函数指针类型的别名
tmp 的类型是
(a) 函数的指针，该函数以两个指向浮点数的指针作为参数(Pointer to function of having two arguments that is pointer to float)
(b) 整型
(c) 函数的指针，该函数以两个指向浮点数的指针作为参数,并且函数的返回值类型是整型(Pointer to function having two argument that is pointer to float and return int)
(d) 以上都不是

答案(c)
分析函数声明，建议不会的看看《C专家编程》
这里介绍一个简单规则:从右向左，遇到括号停下来，将第一个括号里的东西看成一个整体



2、typedef在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
#define dPS struct s * 
typedef struct s * tPS; 
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s的指针。如果可以的话，哪种方法更好呢？为什么？ 
这是一个非常微妙的问题，任何人答对这个问题（正当的原因，而不是猜，如果你没有原因，说不会比猜一个答案要好的多，记住啊，说话是要讲根据的）是应当被恭喜的。答案是：typedef更好。思考下面的例子： 
dPS p1,p2; 
tPS p3,p4;
第一个扩展为 
struct s * p1, p2;
上面的代码定义p1为一个指向结构的指针，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。


=============================== extern ====================================

//extern可以引用其他文件中的全局变量，也可以引用该文件下面声明的全局变量。

1、代码作用域是一件很诡异的事，下面这个函数返回值是什么？
int x = 5;
int f() 
{
	int x = 3;
	{
	  	extern int x;
	  	return x;
	}
}
答案：5

================================ ##和# ====================================

1、下面这段程序的输出结果是：
#include <stdio.h>
#define f(a,b) a##b   //##表示拼接
#define g(a)   #a     //#表示字符串替换
#define h(a)   g(a)
 
// a##b --> ab
// a#b --> a"b"
 
int main()
{   
    printf("%s\n", h(f(1,2)));  
    //h(f(1,2)) --> h(12) --> g(12) --> "12"   
    //h(f(1,2)) --> g(f(1,2)) --> g(1##2) --> g(12) --> "12"
	//h(f(1,2)) --> g(12) -->  "12"	 //此种展开				      
     
    printf("%s\n", g(f(1,2)));  
    //g(f(1,2)) --> #f(1,2) --> "f(1,2)"
    //g(f(1,2)) --> g(12) --> "12"
    //g(f(1,2)) --> "f(1,2)" //此种展开
    
    return 0;
}
当然，你首先要了解##和#的用法，如果不懂的话，本题你可以直接跳过。
解答：
看到这段程序你可能会认为，这两个printf输出的同一个结果，可是答案却非如此，本题的输出是12和f(1,2)，为什么会这样呢？因为这是宏，宏的解开不象函数执行，函数是由里带外。



2、输出结果
#define INIT_OBJ(name, data) \
	struct foo foo_##name = { \
		.id = "fo_"#name"", \
		.num = data, \
	};
struct foo {
	char id[12];
	int num;
};
static void test23()
{
	INIT_OBJ(FOO, 'a');
	printf("%s, %d\n", foo_FOO.id, foo_FOO.num); //fo_FOO, 97
}



3、请问下面的程序输出是什么？（绝对不是10）
#include <stdio.h>
#define PrintInt(expr) printf("%s : %d\n",#expr,(expr))

int main()  
{
    int y = 100;
    int *p;
    p = malloc(sizeof(int));
    *p = 10;
    y = y/*p; /*dividing y by *p */;
    PrintInt(y);
    return 0;
}

参考答案：本题输出的是100。为什么呢？问题就出在 y = y/*p;上了，我们本来想的是 y / (*p) ，然而，我们没有加入空格和括号，结果y/*p中的 /*被解释成了注释的开始。于是，这也是整个恶梦的开始。


