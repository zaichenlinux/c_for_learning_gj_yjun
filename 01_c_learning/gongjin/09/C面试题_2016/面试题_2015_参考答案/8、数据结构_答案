
1、以下性质不是算法特征是（ B）。
A．有穷性 
B．可重用性 
C．确定性 
D．有0个或多个输入

//算法的特征：
		1、有限步内必须完成
		2、确定性（结果唯一性）
		3、有输入和输出
		4、可读性
//衡量算法优劣：
		1、高内聚，低耦合
		2、时间和空间复杂度都比较低
		3、正确性
		4、可行性
		5、鲁棒性（健壮性）
		6、可读性


2. 数组和链表的区别
数组：数据顺序存储，固定大小
链表：数据可以随机存储，大小可动态改变


3. 队列和栈有什么区别？
答：队列先进先出，栈后进先出


4. 什么是平衡二叉树？
答：左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。


5. 以下是两个n阶方阵的乘积C=A*B，求出该算法的时间复杂度。
#define MAX 10
void matmult(int n, float A[MAX][MAX], float B[MAX][MAX], float C[MAX][MAX]) {
	int i,j,k;
	float x;
	for(i=1;i<=n;i++)                //(1)
		for(j=1;j<=n;j++)             //(2)
		{
			x=0;                       //(3)
			for(k=1;k<=n;k++)          //(4)
				x += A[i][k]*B[k][j];   //(5)
			C[i][j] = x;               //(6)
		}
}
解答：
	在该算法中，语句（1）的循环控制变量i要增加到n+1,故它的频度是n+1,但是它的循环体却只能执行n次。语句（2）作为语句（1）的循环体内的语句应执行n次，但语句（2）本身要执行n+1次，所以语句（2）的频度是n(n+1)。
	同理得到语句（3）（4）（5）（6）的频度分别是n^2、n^2*(n+1)、n^3、n^2。则本算法的时间复杂度T(n)=n+1 + n(n+1) + n^2 + n^2*(n+1) + n^3 + n^2 = 2n^3+3n^2+2n+1 = O(2*n^3) = O(n^3)


6、通常情况下我们所说的时间复杂度指的是什么情况下的复杂度（平均情况？最好情况？还是最坏情况）？
		最坏情况
   冒泡排序算法的时间复杂度是什么？分别在什么情况下，冒泡排序的效率最高和最低？
   		时间复杂度是O(n^2)。
        对 待排序序列 已按照要求排好序时效率最高。
   通常在待排序元素数量比较大时，在8种排序算法中可以选择哪几种？
   		快速、归并、堆、基数
   如果待排序元素是double型的，在8种排序方法中不能使用哪种方法？
   		基数排序
   		
   		
7. 下面的程序是用来删除单链表的首元素的函数，请找出其中的问题并加以纠正。【中国某著名综合软件公司2005年面试题】
void RemoveHead(struct node * head)
{
	free(head);
	head = head->next;
}



答：
void RemoveHead(struct node * head)
{
	struct node * p;
	p = head->next;
	head->next = p->next; 
	free(p);
}



8. 如果一棵二叉树节点的前序序列是A、B、C，后序序列是C、B、A，则该二叉树的中序序列是什么？【中国某著名计算机金融软件公司2005年面试题】
答案不唯一，可能是B、C、A，也可能是C、B、A。由前序和后序序列是无法唯一确定一个中序序列的。
	A                    A             A                 A
	
B	        或         B         或         B        或        B

	C              C                          C          C
	
	
补充：已知
	先序：ABCDEFGH
	中序：DCBEAGHF， 求后序(答案：DCEBHGFA)。




9、对于数据结构的问题，如果思路稍有不对，就容易陷入逻辑混乱。我希望自己对数据结构的理解，能够给大家一点帮助。一个经典问题(出栈顺序)如下：
一个栈的入栈序列是a,b,c,d,e 则栈的不可能的输出序列是：（）
A edcba         B decba            C dceab            D abcde

栈之根本——先进后出（first in，last out）初次接触到这个问题的人，或许会认为入栈abcde，所以出栈只能是edcba, 所以BCD都不对。
其实是这个问题描述有歧义，应该是分段入栈的顺序，也就是说，可能先入栈a，取出a，入栈b，取出b……，所以D也是可能的。
知道这个意思了以后，就要明确这个问题的矛盾根本所在：第一次出栈d，说明什么？说明a，b，c一定早已入栈（入栈顺序决定的）。那么在出栈d以后，a，b，c的出栈顺序一定是c，b，a，而不用理会中间穿插着出栈了d后面的字符（因为可以再入栈，再出栈嘛）。所以立即选中C，不用犹豫，理由简单：d出栈了，abc一定已经入栈，那么abc只能以cba的顺序出栈，C不符合.

栈就像个筒子 只能从最外面一个一个的出来
ABCD一次进栈从栈口到里面是DCBA
如果是多选的话 那就是没有一次性放完··
A: A> B> B< C> C< A< D> D< BCAD
B: A> B> C> C< D> D< B< A< CDBA
C: A> A< B＞ B＜ C＞ C＜ D＞ D＜ ABCD
＞表示进 ＜表示出
以此类推···

1。EDCBA 2。DECBA 3。DCEAB 4。ABCDE
选3

堆栈讲究先进后出，后进先出
选项1是abcde先入栈，然后依次出栈，正好是edcba
选项2是abcd先依次入栈，然后d出栈，e再入栈，e出栈
选项3是错误的，不可能a先出栈
选项4是a入栈，然后a出栈；b再入栈，b出栈。。。。。。依此类推



10、用两个栈实现一个队列的功能？
参考答案：
设2个栈为A,B, 一开始均为空.
入队:
将新元素push入栈A;
出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1),


