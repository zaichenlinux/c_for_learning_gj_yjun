/*
位运算符
~  按位取反
~1100 0011  ==  0011 1100

|  按位或 对应的位进行或运算
|   0    1
0   0     1
1   1    1

& 按位与   .........与
&   0    1
0   0    0
1   0    1

>>  右移  无符号类型的移动,超出位直接丢弃
1100  >> 2     0001

<<  左移 ...
1100 << 2    0000

软件控制硬件,控制对应寄存器.
GPIOA  2位  4位 分别控制LED  BEEP   1开  0关
0000 0100 
以0x开头数据就是十六进制
0~9 a  b c d e f
一个十六进制一位,可以用四个二进制来表示
*/
//std  标准  io 
//std lib
#include <stdio.h>
#include <stdbool.h>

int main(int argc, char const *argv[])
{
	#if 0
	GPIOA = 0x4;  //对一个寄存器赋值,一般不应该直接进行赋值,因为会修改了其他位
	//GPIOA |= 0x4; 
	GPIOA = GPIOA  | 0X4;
	GPIOA  |= (0x1 << 2);     // 第2位置1
	GPIOA  |= (0x1 << 4);   // 第四位置1
                        0000   0100  1111 1011
       GPIOA  &=   ~(0x1 << 2);                              //2位清0
       GPIOA  &= ~(0x1<< 4);

       0110 0000
       0110 0000
       5 , 6 置1 
       GPIOA  |=  0x3  << 5
       13  18 清0
       GPIOA	&= ~(0x1 << 13);
       GPIOA  & = ~(0X1 << 18);

       GPIOA = GPIOA | (0x3 << 5)  &  ~(0x1 << 13 | 0x1 << 18);
	#endif
//|| 逻辑或  && 逻辑与 !逻辑取反  ==  !=  逻辑运算
//逻辑运算针对是表达式
 //位运算 针对是数据的每一位
 /*
 ||   表达式1 ||  表达式2
 只要有一个表达式为真,整个表达式为真  ,否则为假
&& 表达式1 && 表达式2
只要有一个表达式为假整个表达式为假,否则为真
==
!=
! 表达式      如果表达式为真, !为假


 /除    %取余数

? :   条件运算符
表达式  ?  表达式1 : 表达式2
a > b ? a:b

++  --
a++
++a
几个重要的优先级
1.    .  -> []  ()  优先级大于*
int *arr[5]   *foo.a
int (*arr)[5]

2. == !=  优先级大于 位操作
(val & mask) != 0
== !=  优先级大于  =
(c = getchar())  != EOF


3.算术运算符优先级高于位运算
(mab<<4) + 2;

,
 */
 	int a = 4, b = 11;
 	printf("%d\n",b%a);

 	c = a, b;
	return 0;
}