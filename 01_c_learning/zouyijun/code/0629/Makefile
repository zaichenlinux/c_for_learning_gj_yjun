
#UNIX平台上的程序员必须会写或者能够修改Makefile文件
#
#Makefile 脚本文件  
#	名称：GNUmakefile(只有用到了GNU特定的语法，才有必要使用这个名字) --> makefile --> Makefile(推荐的名字)
#	作用：实现自动编译，根据文件中描述的规则选择性的执行
#
#make 指令 按照 Makefile中所写的规则来执行
#
#Makefile中的每一条规则，包括如下部分：
#
#目标: 依赖列表 
#	[tab键]命令
#
#一个Makefile中的最上面的一条规则中的那个目标被视为终极目标
#
#其他的规则，顺序是无关的
#
#其中的目标：可以是一个可执行文件，也可以是一个.o文件，还可以是一个目录，或者一个标签
#
#依赖列表：可以是很多个文件，也可以只有一个文件，或根本什么都没有
#命令：是一个合法的shell命令
#
#------------------------------------
#
#
#Makefile文件执行的原理：
#	终极目标，如果不存在，那么就会判断所在规则中的依赖是否存在。如果不存在，会继续向下查看以这些依赖为目标的规则是否存在，存在的话，并且这次的依赖也存在，就会执行所在规则下的命令;如果以这些依赖为目标的规则依然不存在,那么make会继续去隐含规则中查看是否有相应的规则来生成,如果此时还是没有，就会报错退出
#	终极目标，如果不存在，所依赖的的东西存在的话，就会自动执行所在规则下的命令
#	终极目标，如果存在，那么就会比较终极目标和它的依赖的时间戳。如果依赖的时间更新，那么就会自动执行下面的命令
#	
#	查看make的隐含规则：
#  		make -p
#
#目标1： 依赖1 依赖2
#	生成目标1的命令
#
#依赖1：依赖11
#	生成依赖1的命令
#
#依赖2：依赖21
#	生成依赖2的命令
#
#	在某条命令的前面加上@，可以取消本条命令的打印
#------------------------------------------
#
#Makefile中的变量：
#	1> 特殊变量
#		$@ 表示所在规则中的目标
#		$^ 表示所在规则中的所有依赖
#		$< 表示所在规则中的依赖中的第一个
#		$? 表示所在规则中，所有比目标更新的文件
#		$* 表示所在规则中，%模式匹配的部分
#		$$ 表示当前正在运行的进程的进程编号
#
#	2> 自定义变量
#		NAME=123
#		echo $(NAME)
#

# 在Makefile中，""中的变量，值会被自动展开
# ''中的变量，值不会被展开
all: first second third
	@echo "\$$@ = $@"
	@echo '$$^ =' $^
	@echo "$$< = $<"
#	@echo "$? = $?"
#	@echo "$* = $*"
	@echo '$$$$ =' $$$$

first:
	@echo "1"

second:
	@echo "2"

third:
	@echo "3"

#变量的赋值：
B = $A
C := $A #立即展开赋值
A = 10 #延迟赋值
D = 20
D ?= $A #条件赋值：D如果之前有值，那么不会将A的值赋给D;否则将A的值赋给D
E = $A
E += 20 #追加赋值：在之前的值之后，添加空格之后加入新的值
all2:
	@echo "B = " $B
	@echo "C = " $C
	@echo "D = " $D
	@echo "E = " $E

# 如果需要make执行特定的规则中的命令，需要显式的写 "make 目标\标签名称"	

#变量赋值方式中的 = 赋值，可能会导致循环引用，但是make非常智能，会很快检测到。
CD:=$(AB)
AB:=$(CD)
all3:
	@echo '$(AB) =' $(AB)
