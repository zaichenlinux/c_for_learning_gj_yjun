#include <stdio.h>

/*
	内存：段式架构
	从内存低地址开始 --> 高地址：
	1> 代码段：函数和只读数据
		.text: 代码段（函数地址）
		.rodata: 只读数据
	2> 数据段：
		.data: 存放已经被初始化过的变量
		.bss : (block started by symbol 以符号开始的段) 存放未被初始化的变量（包括初始化为0的）
	（.bss段的数据是在程序启动的时候，由操作系统负责将这个段内的数据一次性清0）

	3> 堆区(heap)：存放程序运行过程中动态申请的变量的内存
	4> 栈区(stack)：存放函数内定义的非静态变量 
	// 上面四个段，是用户空间段

	5> 内核段 ： 内核空间段
*/

/*
	作用域：变量的作用范围（能被使用的范围）
		分成四种：
		1> 函数作用域：定义在函数内的非静态局部变量就是这种作用域
		2> 文件作用域：定义在函数外的变量就是这种作用域
		3> 块作用域：定义在函数内的另外一对{}内的变量，就是这种作用域
		4> 函数原型作用域：作用范围是在函数的{}内

	生命周期：变量被开辟空间，直到回收占用的空间的这段时间，就是这个变量的生命周期
		1> 自动生命周期：变量所在的函数被调用，运行到这个变量所在行时，才会开辟这个变量的内存；直到函数调用结束，就回收这个变量的内存
		2> 动态生命周期：在程序运行过程中，才动态申请变量占用的内存，这样的变量就具有动态生命周期；直到动态释放才回收内存
		3> 静态生命周期：在程序启动时，就会开辟空间；直到程序退出才被回收内存

	链接性（不重要）：
		分为：外部链接，内部链接，无链接

	static 的作用： 
		1, 用来修饰局部变量, 这个变量被称为静态局部变量(改变了局部变量的生命周期)
		2, 用来修饰全局变量，这个变量被称为静态全局变量(这个变量就变成了本文件私有的一个全局变量，这里是改变了这个全局变量的作用域)
		3, 用来修饰函数，被修饰的函数就被称为静态函数(这个函数就变成了本文件私有的函数)

	完整的定义一个变量：
		存储类型 数据类型 变量名;

	存储类型：
		static: 静态存储
		extern: 外部存储
		register: 寄存器变量：被放置在寄存器中的变量
		auto: 自动变量 默认所有的非静态局部变量都是这种类型

	extern 的作用：
		用来声明外部变量（外部变量指的是非静态全局变量）
		用来声明函数的（因为所有的函数默认就是全局的，所以extern对于函数就没有什么意义了）
*/

int a; // 非静态全局变量（在.bss段，属于文件作用域）
static int sa; // 静态全局变量（在.bss段，属于文件作用域）

int main(int argc, char *argv[])
{
	printf("全局变量 a = %d\n", a); 
	/*auto*/ int a = 10; //stack

	static int sa; // 静态局部变量（在.bss段）
	static int sa2 = 10; // 静态局部变量（在.data段）

	{ // 代码块作用域
		int a = 100;

		{ // 代码块作用域
			a = 200;
			int a = 300;
		}

		printf("a = %d\n", a);
	}
	
	printf("a = %d\n", a);

#if 1
	void visit();
	visit();
#endif
	//void register_variable();
	//register_variable();

	char *ps = "hello world"; // ps在stack, "hello world"在.rodata段
	//*ps = 'H'; //运行时错误

	return 0;
}

// 寄存器变量
void register_variable()
{
	register int a; // 定义了一个寄存器变量
	// printf("寄存器变量：%p\n", &a); // 不能对寄存器变量取地址，因为这个变量可能存在于寄存器中
}

/*static*/ int foo(int a, char c) // a和c都是具有函数原型作用域的变量，作用范围还是在函数的一对{}之间
{
	return a + c;
}
