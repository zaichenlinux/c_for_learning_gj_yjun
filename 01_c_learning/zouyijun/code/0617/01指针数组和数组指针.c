#include <stdio.h>

/*
	指针变量：以地址为值的变量
	指针变量的类型：声明中去掉变量名之后剩下的部分，就是这个指针变量的类型
	指针变量指向的变量的类型：声明中去掉变量名和前面的一个*号，剩下的部分就是
	
	* 在不同的上下文中，意义不同：
	1> 在声明中：仅用来说明后面的这个变量是一个指针变量
	2> 在赋值符号=的左边，修改指针变量指向的那个变量中的值
	3> 在赋值符号=的右边，间接访问指针变量指向的那个变量中的值
	4> 作为二元运算符时，表示乘号(比如：3*4)
	在上面的2>和3>中，*是间接寻址运算符（或者称为间接访问运算符）

	& 在不同的上下文中，意义也不相同：
	1> && 逻辑与
	2> & 按位与运算符 (比如：3 & 4)
	3> &变量 ： &是取地址运算符，表示取出变量的地址
	
	数组：存放同一种数据类型的元素的一种数据结构
	数组的元素类型可以是任何合法的数据类型，除了函数类型外
	[]是数组的标志
	1> []出现在声明中，表示当前声明的这个变量是一个数组
	2> []出现在表达式中，表示下标运算符（比如：a[-2] --> 先偏移：a+2， 然后间接访问：*(a+2)）
	
	数组名只要出现在了表达式中，类型就是指向其中首个元素的指针类型
	int a[3];
	int b = *(a + 1); // a的类型是：int*
	
	int a2[2][3];
	int c = *(*(a2 + 1) + 2); // a2的类型是：int (*)[3]
	c = *(a2[1] + 2); // a2[1]的类型是：int*

	字符串：
		char s[] = {'1', '2', '3'}; // 字符数组 sizeof = 3
		char s[3] = {'1', '2', '3'}; // 字符数组
		char s[] = "123"; // 字符串 sizeof = 4

	strlen函数，用来计算字符串的有效长度（'\0'之前的所有字符个数）
*/

// 将参数转为大写字母返回出去
int foo(char x) // foo函数的类型是：int (char)
{
	return x >= 'a' ? x - ('a' - 'A') : x; 
}

// 数组初始化式(C99特性)
void assignment()
{
	int a[6] = {[3] = 1, [1] = 7}; // 给制定下标元素赋值
	printf("a[0] = %d, a[1] = %d\n", a[0], a[1]);
}

void arr()
{
	// 符合字面量(C99才出现的语法)：
	int a = ((int [10]){1,2,3})[2]; // 定义了一个无名数组(有10个元素，其中前3个元素分别被赋值为1,2,3)，这个数组并没有被开辟空间，我们仅仅是利用这个数组，取出这个数组中的某个元素值 

	int b = ((int []){1,2,3, [0] = 7, 8, [1] = (88,99)})[1]; // 定义了一个有3个元素的一维数组

	printf("a = %d, b = %d\n", a, b);

	int *p = (int []){1,2,3}; // 定义一个指针，指向一个无名数组中的首元素
	printf("%d\n", *(p + 1));
}

void arr_of_ptr() // 指针数组：元素类型是指针类型的数组
{
	char *s[2] = {"linux", "world"};
	printf("%s\n", s[0]);
	printf("%s\n", *s + 1);
	printf("%s\n", *(s + 1));
}

void ptr_to_arr() // 数组指针：指向数组的指针
{
	//int aa = 10, *q;
	//q = &aa; // *q = *&aa; -->  *q == aa

	int a[3] = {1,2,3}; // a[1]
	int (*p)[3] = &a;  // *p == a

	printf("%d\n", *(*p + 1)); // *p == a
	// *(*p + 1) == *(p[0] + 1) == p[0][1] ==> a == p[0] ==> 
								// a == *(p+0) ==> a == *p
	// *p == *(p + 0) == p[0]

	// *(a + 1) == a[1]
	// a[1] == *(a + 1)
}

int main()
{
	//int a[2] = {1,2,3}; // 错误，初始化列表元素个数不能超过数组[]中的数值
	//assignment();
	arr();

	//arr_of_ptr();
	//ptr_to_arr();

	return 0;
}
