#include <stdio.h>

/*
	1字节 = 8位

	C语言中提供了6个位运算符：（针对的是整数）
		二元运算符：
		& 按位与  参加运算的两个操作数，对应位如果都为1,该位的结果是1;其他情况都是0
		3 & 5
		3：00000011
		5：00000101
		&
		------------
		   00000001 = 1

		| 按位或  参加运算的两个操作数，对应位只要有一个为1,该位的结果是1;其他情况都是0
		3 | 5
		3：00000011
		5：00000101
		|
		------------
		   00000111 = 7

		^ 按位异或  参加运算的两个操作数，对应位相同结果是0,不同结果是1  
		3 ^ 5
		3：00000011
		5：00000101
		^
		------------
		   00000110 = 6

		 ^的运算规则：
		 	1, 一个数和0异或，保持原数不变
				3^0 = 0011^0000 = 0011 
			2, 一个数和自己异或，结果是0
		   		3^3 = 0011^0011 = 0000	
			3, 异或操作的操作数，可以进行交换
				3^5^3 = 3^3^5 = 0^5 = 5
				0011^0101 = 0110^0011 = 0101


		 一元运算符：
		 ~ 按位取反  将参加运算的一个操作数的每一位按位取反，即1变0,0变1
		5: 00000101
		~
		------------
		   1111 1010 = fa

		二元运算符：
		<< 按位左移 左操作数 按位向左移动 右操作数指定的位数
			左边移出去的位丢弃，右边空出来的位补0
		3 << 1
		00000000 00000000 00000000 00000011
		<< 1
		-----------------------------------
	  0 0000000 00000000 00000000 000000110 = 6

	  	左移一位，在数值上，相当于乘以2


		>> 按位右移 左操作数 按位向右移动 右操作数指定的位数
			如果左操作数是无符号数或者非负数，右移，左边空出来的位补0, 右边移出去的位丢弃
			如果左操作数是负数：右边移出去的位全部丢弃，左边空出来的位因不同平台的实现而异：某些平台补0; 某些平台补入符号位。
		
		3 >> 1
		00000000 00000000 00000000 00000011
		>> 1
		-----------------------------------
	    00000000 00000000 00000000 00000001 (1) = 1

	  	右移一位，在数值上，相当于除以2

   */

/*
	进制：计数的一种方式
		常用的进制：10进制，2进制，16进制，8进制
		10进制：逢10进1  0...9
		2进制：逢2进1    0...1
		16进制：逢16进1  0...9a...f(或者0...9A...F)
		8进制：逢8进1    0...7

		* * * * * *
	    * * * *	* *

		10进制：12
		2进制：1100
		16进制: C
		8进制：14
   */

/*
	正数和负数在内存中的表示：

	原码：将整数的二进制形式的最高位用符号位填充
		正数 2的原码：00000000 00000000 00000000 00000010
		负数-2的原码：10000000 00000000 00000000 00000010
	反码：
		正数 反码 = 原码
			2的反码：00000000 00000000 00000000 00000010
		负数 反码 = 除了符号位，其他位按位取反
		   -2的反码：11111111 11111111 11111111 11111101
	补码：
		正数 补码 = 原码
			2的补码：00000000 00000000 00000000 00000010
		负数 负数的反码 + 1
		   -2的补码：11111111 11111111 11111111 11111110
		   			 ff       ff       ff       fe

	整数在内存中都是以二进制补码形式存放的
	
	10 + 2
	10的补码：00000000 00000000 00000000 00001010
	 2的补码：00000000 00000000 00000000 00000010
	 +
	 ----------------------------------------------
	          00000000 00000000 00000000 00001100 = 12

	10 - 2 = 10 + (-2)
	10的补码：00000000 00000000 00000000 00001010
	-2的补码：11111111 11111111 11111111 11111110
	 +
	 ----------------------------------------------
	        1 00000000 00000000 00000000  00001000 = 8

	补码转换为原码：
		正数：原码 = 补码
		负数：符号位不变，其余位按位取反后+1

	3 - 4
	 3的补码：00000000 00000000 00000000 00000011
	-4的补码：11111111 11111111 11111111 11111100
	+
	----------------------------------------------
	          11111111 11111111 11111111 11111111 补码
			  10000000 00000000 00000000 00000001 原码 = -1
   */

/*
	进制转换：
		2进制 --> 10进制
		1101 = 1×2的0次方 + 0×2的1次方 + 1×2的2次方 + 1×2的3次方
		     = 1 + 0 + 4 + 8 = 13

		10进制 --> 2进制
		13 = 2的3次方 + 2的2次方 + 2的0次方 = 1000 + 100 + 1 = 1101

		16进制 --> 10进制
		0x1d = 13×16的0次方 + 1×16的1次方 = 13+16 = 29

		10进制 --> 16进制
		29 不断除以16， 反过来取余数


		2进制 --> 16进制
		1101 1110 = 0xde

		2进制 --> 8进制
		011 011 110 = 0336	
   */

/*
	n位二进制数的取值范围：
	
	1位 
	0 1 = 0...2的1次方-1

	2位
	00 01 10 11
	0  1  2  3   =  0...2的2次方-1

	3位
	000 001 010 011 100 101 110 111
	0	1	2	3	4	5	6	7  = 0...2的3次方-1

	n位
	非负数取值范围： 0 ... 2的n次方-1
	负数取值范围：   -(2的n-1次方) ... 2的n-1 - 1
   	
	int = 4字节
	01111111 11111111 11111111 11111111

	5位2进制数的最大值：11111 = 31
   */

// 类型限定符号
void type_specify()
{
	//unsigned signed long short
	//unsigned 无符号数 数据的最高一位不视为数据的符号位，而视为数据的有效位
	unsigned int a = 0b1111111100000000000000001101;

	// signed 有符号数 数据的最高一位是数据的符号位，如果是1则是负数;如果是0则是正数
	signed int b = 0b1111111100000000000000001101;
	signed int c = 0b0111111100000000000000001101;

	long int li = 6578901122456888888L; // 等价于 long li
	printf("li = %ld\n", li);

	printf("size long = %lu\n", sizeof(long));
	printf("size long long = %lu\n", sizeof(long long));
	printf("size long double = %lu\n", sizeof(long double));

	short int d = 266; // 等价于short d

	/*
		 16位 	32位	64位
	char  1		 1		1
	int	  2字节	 4		4
	long  4		 4		8
	short 2		 2		2
	float 		 4		4
	double		 8		8
	long long    8		8
	long double  12		16	
*/
}

int int_mem()
{
	int a = 12; // 00000000 00000000 00000000 00001100

	// 栈空间，CPU寻址：从高地址开始，向低地址寻址的
	// 0xff04  00000000
	// 0xff03  00000000
	// 0xff02  00000000
	// 0xff01  00001100

	char s[4] = "123";
	printf("&s[0] = %p\n", s + 0);
	printf("&s[1] = %p\n", s + 1);
}

#include <math.h>
int main()
{
	type_specify();
	int_mem();

	printf("%#x\n", 3 & 5);
	printf("%#x\n", 3 | 5);
	printf("%#x\n", 3 ^ 5);
	printf("%#x\n", ~5);
	printf("%#x\n", 3 << 1);
	printf("%#x\n", 3 >> 1);

	int a = 12; // 默认是10进制整数
	int b = 012; // 8进制
	int c = 0x12; // 16进制
	int d = 0b1100; // 2进制
	printf("10进制 = %d\n", a);
	printf("16进制 = %#x\n", a);
	printf("8进制 = %o\n", a);
	printf("10进制 = %d\n", d);

	d = 0x1f;
	printf("16进制 = %#X\n", d);

	int e = -2;
	printf("%#x\n", e);

	printf("2^31-1 = %lf\n", pow(2, 31) - 1);


	void bit_opr_use();

	bit_opr_use();

	return 0;
}

// 位运算符的使用
void bit_opr_use()
{
	//1, 需要定义一个变量的值每一位都为1的数
	int a = ~0;

	//2, 需要一个变量的值除了最低5位是0以外，其他位均为1
	a = ~0x1f;

	//3, 需要将一个整数的第4位置1
	a = 0b101001;
	//a |= 0b10000;
	a |= (1 << 4); // 更通用的做法
	printf("%#x\n", a); // 0x39

	//4, 需要将一个整数的第4位清0
	a &= ~(1 << 4);
	printf("%#x\n", a); // 0x29

	//5, 判断一个数是否是偶数
	/*
		2: 0010
		6: 0110
		8: 1000

		5: 0101
		7: 0111
	   */
	int is_even_num(int n);
	printf("%s数\n", is_even_num(5) ? "偶" : "奇");

	//6, 交换两个变量的值，不能使用第三个变量
	void swap_num(int *a, int *b);
	a = 3;
	int b = 5;
	swap_num(&a, &b);
	printf("swap, a = %d, b = %d\n", a, b);

	a = 8, b = 6;
	void swap_number(int *a, int *b);
	swap_number(&a, &b);
	printf("swap_number, a = %d, b = %d\n", a, b);


	//7, 判断一个数是否2的幂
	/*
	   	0: 不是
		1：0001
		4: 0100
		3: 0011

		8: 1000
		7: 0111

		6: 0110
		5: 0101	
	   */
	int is_power_2(int n);
	int is_pow_2(int n);
	int n = 6;
	printf("%d%s是2的幂\n", n, is_power_2(n) ? "" : "不");
	printf("%d%s是2的幂\n", n, is_pow_2(n) ? "" : "不");
}

int is_even_num(int n)
{
	return !(n & 1);
}

void swap_number(int *a, int *b) // 8 6
{
	*a = *a + *b; // *a = 14 // *a+*b 很可能超过int类型的取值范围，导致结果不正确
	*b = *a - *b; // *b = 14 - 6 = 8
	*a = *a - *b; // *a = 14 - 8 = 6
}

// 时间或空间
void swap_num(int *a, int *b)
{
	*a ^= *b; // *a = *a^*b;
	*b ^= *a; // *b = *b^(*a^*b) = *b^*a^*b = *b^*b^*a = *a
	*a ^= *b; // *a = *a^*b = *a^*b^*a = *a^*a^*b = *b
}

int is_power_2(int n)
{
	if (n == 0) 
		return 0;

	return !(n & (n-1));
}

int is_pow_2(int n)
{
	if (n == 0) 
		return 0;

	// n = 6: 0110 = 0011
	// n = 4: 0100 = 0010 = 0001
	while (!(n & 1)) {
		n >>= 1;
	}

	return n == 1;
}
