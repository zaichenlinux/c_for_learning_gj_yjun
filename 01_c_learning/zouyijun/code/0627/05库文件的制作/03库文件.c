
库文件：是由很多个目标文件打包而成的

库文件的目的：很多程序在使用同一段代码，对于这个代码的具体实现是不可知的。凡是有这样特点的一段代码（一个函数）都可以将其制作为库文件。

目标文件：
	gcc -c xx.c 
	gcc -c yy.c

制作静态库（存档\归档）文件：
	ar -crsv lib自定义静态库文件名.a xx.o yy.o
	    
	其中，选项注释如下：
		-c: 文件不存在，就被创建; 如果提前使用修改器来创建这个文件，就不会出现警告
		-r 插入指定的文件（如果存档文件中不存在这个文件，就会插入到最后;如果存在了，就先删除存档文件中的这个同名文件，之后再插入新文件）
		-s 给插入到存档文件中的那些文件添加索引
		-v 可以看到过程

		其中，存档文件名，必须是：
			开始部分以 lib 开头
			后缀必须是 .a
			中间的部分可以自定义


	使用：
		gcc 其他源文件 自己制作的库文件 [-I头文件所在的目录]  // 编译为可执行文件 （如果头文件不在当前目录，需要用-I选项指定所在目录）

		制作为静态库文件之后，制作出静态库文件的那些源文件和他们生成的目标文件就可以删除了，因为已经被编译进库文件了

		静态库文件是以代码拷贝的方式被编译进可执行文件中的，所以那些文件才能被删除

		
	==============================


	共享库
		名字因操作系统而异：
			windows 动态链接库
			mac 动态库
			UNIX(包括linux) 共享库


	制作共享库：
		1, 由.c源文件生成位置无关的.o目标文件
			gcc xx.c -fPIC -c
				-f file
				-PIC position independent code

		2, 由第一步生成的目标文件，制作共享库文件
			gcc -shared -o lib自定义部分.so xx.o


		上面第1和第2步可以合成一步：
			gcc -shared -fPIC -o lib自定义部分.so xx.c

		3, 链接
			gcc 其他源文件 共享库文件 

		4, 运行
			./a.out 
			一般情况下，运行会失败。原因是：编译器只会到指定目录查找共享库文件（指定目录指的是：/lib 和 /usr/lib）

			在真正运行之前，可以先检查一下，是否需要链接的库文件都被找到了，可以使用：
			ldd ./a.out 来查看

		解决方案：
			第一种：将共享库文件拷贝到/lib或者/usr/lib目录
			第二种：需要将当前制作出来的共享库文件所在目录，追加到/etc/ld.so.conf文件中，但是如果系统没有这个文件，那是没用的
			修改完这个文件之后，需要更新一下这个文件：
				ldconfig /etc/ld.so.conf			
			第三种：
			添加共享库文件所在目录到环境变量LD_LIBRARY_PATH中。写法如下：
			export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:`pwd`
			其中pwd就是共享库所在的目录
			或者
			export LD_LIBRARY_PATH=`pwd`:$LD_LIBRARY_PATH  // 是将共享库文件所在目录添加到这个环境变量所表示的目录中的最前面

		上面3种方案，第3种是推荐的方式;第1种是很多公司采用的方式，主要是因为比较简单(也有些公司，是将共享库文件在/lib或者/usr/lib目录中建立软链接文件，来达到同样的效果)


	------------------------------------------------

	总结：
		库文件是用来达到程序的复用的

		静态库：
		是将需要复用的代码以代码拷贝的方式，编译进可执行文件，所以在生成了可执行文件之后，静态库文件就不再需要了。
		因为是采用拷贝的方式，所以会使得最终的可执行文件的尺寸变大。
		静态库文件只在编译的时候需要，在运行的时候就不再需要了。
		一旦静态库文件做了修改，那么就需要重新编译所有的文件。


		共享库：
		是在程序运行过程中，在内存中动态加载共享库文件中需要使用的函数，在编译时仅仅是对需要调用的函数做一个简单的符号引用。
		无论是在编译时，还是运行时，都需要有共享库的存在。
		共享文件一旦被加载进内存，在内存中同时运行的任何程序，如果需要使用到这个共享库文件中的某个函数，那么可以共享这同一个库文件。这样就能够带来共享代码，节约内存的好处。
		共享库文件一旦做了修改，是不需要重新编译和链接的。可执行文件的更新，就是通过更新共享库文件来做到的。所以有很多的程序的升级，就仅仅需要升级共享库文件，就可以达到升级整个程序的目地。
		

		不管是静态库，还是共享库，下面的选项是通用的：
		-I头文件所在目录   // 目录可以是相对路径，可以是绝对路径
		-L库文件所在目录   
		-l库文件名（自己定义的部分）
		
		-L 必须在 -l 之前出现

		如果，在同一个目录下，同时存在了同名的静态库文件和共享库文件，那么编译器会优先加载哪个库文件？
		会优先调用共享库文件

		如果非要加载静态库文件，可以：
		gcc -static 其他源文件 -L库文件所在目录 -l自定义的库文件名 -I头文件所在目录 



